@page "/workflows/{id:guid}/manage"
@using FlowSynx.Client.Messages.Requests.Workflows
@inject IWorkflowService WorkflowService
@inject IJSRuntime JSRuntime

@attribute [Authorize]
@inject IAccessTokenProvider TokenProvider
@inject IFlowSynxClient FlowSynxClient
@inject ISnackbar SnackBar
@inject NavigationManager Navigation

<PageTitle>FlowSynx Workflow designer</PageTitle>

<HeaderTitle Title="Workflow designer" Description="A visual interface to create, edit, and manage workflow." />

<MudStack Row="true" Spacing="2" Class="">
    <MudButton Variant="Variant.Outlined"
               Size="@Size.Small"
               Color="Color.Default"
               StartIcon="@Icons.Material.Filled.Save"
               Disabled="@IsProcessing"
               OnClick="Save">
        Save
    </MudButton>

    <MudButton Variant="Variant.Outlined"
               Size="@Size.Small"
               Color="Color.Default"
               Disabled="@IsProcessing"
               OnClick="ToggleMode">
        @(_jsonMode ? "Switch to Designer" : "Switch to JSON")
    </MudButton>

    <MudButton Variant="Variant.Outlined"
               Size="@Size.Small"
               Color="Color.Default"
               Disabled="@IsProcessing"
               OnClick="ExportJson">
        Export JSON
    </MudButton>

    <MudButton Variant="Variant.Outlined"
               Size="@Size.Small"
               Color="Color.Default"
               Disabled="@IsProcessing"
               OnClick="ImportJson">
        Import JSON
    </MudButton>
</MudStack>

<MudDivider Class="my-2" />

@if (!_jsonMode)
{
    <WorkflowDesigner Workflow="@Workflow" />
}
else
{
    <WorkflowJsonEditor JsonContent="@_workflowJson" JsonContentChanged="v => _workflowJson = v" />
}

@code {
    [Parameter]
    public Guid id { get; set; }

    private bool IsProcessing = false;
    private Workflow Workflow => WorkflowService.Get();
    private bool _jsonMode;
    private string? _workflowJson;
    private UpdateWorkflowRequest UpdateWorkflowRequest = new UpdateWorkflowRequest 
    { 
        Id = Guid.Empty , 
        Definition = "" 
    };

    protected override async Task OnInitializedAsync()
    {
        await LoadWorkflow();
    }

    private async Task LoadWorkflow()
    {
        try
        {
            IsProcessing = true;
            var accessTokenResult = await TokenProvider.GetAccessTokenAsync();
            if (string.IsNullOrEmpty(accessTokenResult))
            {
                SnackBar.Add("No token available or user not authenticated.", Severity.Error);
                return;
            }
            var authenticationStrategy = new FlowSynx.Client.Authentication.BearerTokenAuthStrategy(accessTokenResult);

            FlowSynxClient.SetAuthenticationStrategy(authenticationStrategy);
            var workflowResult = await FlowSynxClient.Workflows.DetailsAsync(new WorkflowDetailsRequest{ Id = id });

            if (workflowResult.StatusCode != 200)
            {
                SnackBar.Add("Server error while fetching the workflow.", Severity.Error);
                return;
            }
            var payload = workflowResult.Payload;
            if (!payload.Succeeded)
            {
                foreach (var message in payload.Messages)
                    SnackBar.Add($"Get workflow error:\n{message}", Severity.Error);

                return;
            }

            _workflowJson = payload.Data.Workflow;
            WorkflowService.SetJson(_workflowJson);
        }
        catch (Exception ex)
        {
            SnackBar.Add($"Unexpected error: {ex.Message}", Severity.Error);
        }
        finally
        {
            IsProcessing = false;
        }
    }

    private void ToggleMode()
    {
        _jsonMode = !_jsonMode;
        if (_jsonMode)
            _workflowJson = WorkflowService.GetJson();
    }

    private void ExportJson()
    {
        _workflowJson = WorkflowService.GetJson();
        _jsonMode = true;
    }

    private void ImportJson()
    {
        if (!string.IsNullOrWhiteSpace(_workflowJson))
        {
            WorkflowService.SetJson(_workflowJson);
            _jsonMode = false;
        }
    }

    private async Task Save()
    {
        try
        {
            IsProcessing = true;
            string? token;
            var accessTokenResult = await TokenProvider.GetAccessTokenAsync();

            if (string.IsNullOrEmpty(accessTokenResult))
                token = "No token available or user not authenticated.";
            else
                token = accessTokenResult;

            var authenticationStrategy = new FlowSynx.Client.Authentication.BearerTokenAuthStrategy(token);
            FlowSynxClient.SetAuthenticationStrategy(authenticationStrategy);

            if (_jsonMode)
            {
                if (string.IsNullOrWhiteSpace(_workflowJson))
                {
                    SnackBar.Add("Please provide a valid JSON definition.", Severity.Error);
                    return;
                }
                UpdateWorkflowRequest.Definition = _workflowJson;
            }
            else
            {
                UpdateWorkflowRequest.Definition = WorkflowService.GetJson();
            }

            UpdateWorkflowRequest.Id = id;

            var result = await FlowSynxClient.Workflows.UpdateAsync(UpdateWorkflowRequest);
            if (result.StatusCode != 200)
            {
                SnackBar.Add("Server error while processing the request.", Severity.Error);
                return;
            }

            var payload = result.Payload;
            if (!payload.Succeeded)
            {
                foreach (var message in result.Payload.Messages)
                    SnackBar.Add($"Update workflow error:\n{message}", Severity.Error);

                return;
            }
            else
            {
                SnackBar.Add("Workflow updated successfully!", Severity.Success);
                Navigation.NavigateTo("/workflows", true);
            }
        }
        catch (Exception ex)
        {
            SnackBar.Add($"Unexpected error: {ex.Message}", Severity.Error);
        }
        finally
        {
            IsProcessing = false;
        }
    }
}