@using Microsoft.AspNetCore.Components
@using System.Text.Json
@implements IAsyncDisposable

@inject IJSRuntime JSRuntime
@inject IDialogService DialogService

<MudPaper Class="designer-root" Elevation="0">
    <!-- Floating Palette Drawer -->
    <MudDrawer Open="@IsPaletteVisible"
               Anchor="Anchor.Right"
               Elevation="8"
               Variant="DrawerVariant.Temporary"
               OverlayAutoClose="false"
               Width="400px"
               Class="palette-drawer glass">

        <MudStack Class="pa-4" Spacing="1">
            <MudStack Row AlignItems="AlignItems.Center">
                <MudIcon Icon="@Icons.Material.Filled.Extension" Size="Size.Medium" Color="Color.Primary" />
                <MudText Typo="Typo.h6" Class="ml-2">Plugins</MudText>
                <MudSpacer />
                <MudIconButton Icon="@Icons.Material.Filled.Close"
                               Color="Color.Default"
                               Size="Size.Medium"
                               OnClick="TogglePalette" />
            </MudStack>

            <MudText Typo="Typo.caption" Class="gray-text">
                Click or drag to add nodes
            </MudText>

            <SearchablePluginsList OnItemClick="AddNodeTemplate" />
        </MudStack>
    </MudDrawer>

    <!-- Canvas -->
    <MudPaper Class="canvas-wrap">
        <MudPaper Class="canvas-appbar" Elevation="0">
            <MudStack Row AlignItems="AlignItems.Center" Spacing="1">
                <MudTooltip Text="Add plugin">
                    <MudFab StartIcon="@Icons.Material.Filled.Add"
                            Color="Color.Primary"
                            Size="Size.Large"
                            Label="Add Plugin"
                            OnClick="TogglePalette" />
                </MudTooltip>

                <MudDivider Vertical="true" />

                @if (SelectedTask != null)
                {
                    <MudTooltip Text="Task properties. Click to modify properties">
                        <MudChip T="string"
                                 Color="Color.Default"
                                 Variant="Variant.Outlined"
                                 Size="Size.Large"
                                 Icon="@Icons.Material.Filled.Info"
                                 OnClick="() => ShowPropertiesDialog(SelectedTask)">
                            Selected Task: <b>@SelectedTask.Name</b>
                        </MudChip>
                    </MudTooltip>
                }

                <MudSpacer />

                <MudPaper Class="zoom-controls" Elevation="4">
                    <MudIconButton Icon="@Icons.Material.Filled.CenterFocusStrong"
                                   Size="Size.Medium"
                                   Variant="Variant.Text"
                                   OnClick="Center" />

                    <MudIconButton Icon="@Icons.Material.Filled.ZoomIn" Size="Size.Medium" OnClick="ZoomIn" />
                    <MudIconButton Icon="@Icons.Material.Filled.ZoomOut" Size="Size.Medium" OnClick="ZoomOut" />
                    <MudIconButton Icon="@Icons.Material.Filled.RestartAlt" Size="Size.Medium" OnClick="ZoomReset" />
                </MudPaper>
            </MudStack>
        </MudPaper>

        <MudPaper id="drawflow"></MudPaper>
    </MudPaper>
</MudPaper>

@code {
    [Parameter] public WorkflowContainer WorkflowContainer { get; set; }

    private WorkflowTask SelectedTask;
    private string _deps;
    private string _newKey;
    private string _newValue;
    private DotNetObjectReference<WorkflowDesigner> _selfRef;
    private bool IsPaletteVisible = false;

    private void TogglePalette()
    {
        IsPaletteVisible = !IsPaletteVisible;
    }

    private Task ZoomIn() => JSRuntime.InvokeVoidAsync("fsDrawflow.zoomIn").AsTask();
    private Task ZoomOut() => JSRuntime.InvokeVoidAsync("fsDrawflow.zoomOut").AsTask();
    private Task ZoomReset() => JSRuntime.InvokeVoidAsync("fsDrawflow.zoomReset").AsTask();
    private Task Center() => JSRuntime.InvokeVoidAsync("fsDrawflow.center").AsTask();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _selfRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("fsDrawflow.init", "drawflow", _selfRef);
            await LoadWorkflowIntoCanvas();
        }
    }

    private async Task LoadWorkflowIntoCanvas()
    {
        await JSRuntime.InvokeVoidAsync("fsDrawflow.clear");

        foreach (var task in WorkflowContainer.Workflow.Tasks)
        {
            var pluginType = task.Type ?? "Unknown";
            var parts = pluginType.Split(':', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
            var displayType = parts.Length == 2
                ? $"{parts[0]} ({parts[1]})"
                : pluginType; // fallback to the original string

            var data = new
            {
                name = task.Name,
                type = displayType,
                operation = task.Execution.Operation,
                parameters = task.Execution.Parameters
            };

            var id = await JSRuntime.InvokeAsync<int>(
                "fsDrawflow.addNode",
                task.Name,
                data,
                (double)(task.Position.X == 0 ? 100 : task.Position.X),
                (double)(task.Position.Y == 0 ? 100 : task.Position.Y)
            );
            task.NodeId = id.ToString();
        }

        foreach (var t in WorkflowContainer.Workflow.Tasks)
        {
            foreach (var dep in t.FlowControl.Dependencies)
            {
                var from = WorkflowContainer.Workflow.Tasks.FirstOrDefault(x => x.Name == dep);
                if (from != null)
                    await JSRuntime.InvokeVoidAsync("fsDrawflow.connect", from.NodeId, t.NodeId);
            }
        }
    }

    private async Task AddNodeTemplate(string type)
    {
        var newTask = new WorkflowTask
        {
            Name = $"{type}-{WorkflowContainer.Workflow.Tasks.Count + 1}",
            Type = type,
            Execution = new ExecutionConfig
            {
                Specification = new Dictionary<string, object?>()
            },
            Position = new(
                120 + (WorkflowContainer.Workflow.Tasks.Count % 5) * 140,
                120 + (WorkflowContainer.Workflow.Tasks.Count / 5) * 120
            )
        };

        WorkflowContainer.Workflow.Tasks.Add(newTask);

        var data = new
        {
            name = newTask.Name,
            type = type,
            parameters = newTask.Execution.Parameters
        };

        var id = await JSRuntime.InvokeAsync<int>(
            "fsDrawflow.addNode",
            newTask.Name,
            data,
            (double)newTask.Position.X,
            (double)newTask.Position.Y
        );

        newTask.NodeId = id.ToString();
        StateHasChanged();
    }

    private void SetParam(string key, string value) => SelectedTask.Execution.Parameters[key] = value;
    private void RemoveParam(string key) => SelectedTask.Execution.Parameters.Remove(key);
    private void AddParam()
    {
        if (!string.IsNullOrWhiteSpace(_newKey))
        {
            SelectedTask.Execution.Parameters[_newKey] = _newValue;
            _newKey = _newValue = null;
        }
    }

    private Task UpdateNodeTitle() =>
        SelectedTask != null ? JSRuntime.InvokeVoidAsync("fsDrawflow.updateNodeTitle", SelectedTask.NodeId, SelectedTask.Name, SelectedTask.Type).AsTask() : Task.CompletedTask;

    private async void ShowPropertiesDialog(WorkflowTask task)
    {
        var options = new DialogOptions
            {
                CloseButton = false,
                MaxWidth = MaxWidth.Small,
                BackdropClick = false,
                CloseOnEscapeKey = false,
                BackgroundClass = "blur-dialog-background"
            };

        var parameters = new DialogParameters
            {
                ["SelectedTask"] = task,
                ["OnUpdated"] = EventCallback.Factory.Create(this, async () =>
                {
                    await UpdateNodeTitle();
                    StateHasChanged();
                })
            };

        await DialogService.ShowAsync<WorkflowNodeProperties>("Properties", parameters, options);
    }

    private void UpdateDepsFromText() =>
        SelectedTask.FlowControl.Dependencies = _deps?.Split(',').Select(s => s.Trim()).Where(s => !string.IsNullOrWhiteSpace(s)).ToList() ?? new();

    [JSInvokable]
    public Task OnNodeSelected(string id)
    {
        SelectedTask = WorkflowContainer.Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        _deps = SelectedTask != null ? string.Join(',', SelectedTask.FlowControl.Dependencies) : string.Empty;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeUnselected() { SelectedTask = null; StateHasChanged(); return Task.CompletedTask; }

    [JSInvokable]
    public Task OnConnectionCreated(string fromId, string toId)
    {
        var from = WorkflowContainer.Workflow.Tasks.FirstOrDefault(x => x.NodeId == fromId);
        var to = WorkflowContainer.Workflow.Tasks.FirstOrDefault(x => x.NodeId == toId);
        if (from != null && to != null && !to.FlowControl.Dependencies.Contains(from.Name))
            to.FlowControl.Dependencies.Add(from.Name);
        _deps = SelectedTask == to ? string.Join(',', to.FlowControl.Dependencies) : _deps;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnConnectionRemoved(string fromId, string toId)
    {
        var from = WorkflowContainer.Workflow.Tasks.FirstOrDefault(x => x.NodeId == fromId);
        var to = WorkflowContainer.Workflow.Tasks.FirstOrDefault(x => x.NodeId == toId);
        to?.FlowControl.Dependencies.Remove(from?.Name);
        _deps = SelectedTask == to ? string.Join(',', to.FlowControl.Dependencies) : _deps;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeRemoved(string id)
    {
        var t = WorkflowContainer.Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        if (t != null)
        {
            WorkflowContainer.Workflow.Tasks.Remove(t);
            foreach (var o in WorkflowContainer.Workflow.Tasks) o.FlowControl.Dependencies.Remove(t.Name);
            if (SelectedTask == t) { SelectedTask = null; _deps = string.Empty; }
        }
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeDoubleClicked(string id)
    {
        var task = WorkflowContainer.Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        if (task != null)
        {
            SelectedTask = task;
            ShowPropertiesDialog(task);
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeProperties(string id)
    {
        var task = WorkflowContainer.Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        if (task != null)
        {
            SelectedTask = task;
            ShowPropertiesDialog(task);
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeMoved(string id, double? x, double? y)
    {
        var task = WorkflowContainer.Workflow.Tasks.FirstOrDefault(t => t.NodeId == id);
        if (task != null && x.HasValue && y.HasValue)
        {
            task.Position = new((int)x.Value, (int)y.Value);
            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    public ValueTask DisposeAsync()
    {
        _selfRef?.Dispose();
        return ValueTask.CompletedTask;
    }
}