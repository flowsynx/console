@using Microsoft.AspNetCore.Components
@implements IAsyncDisposable

@inject IJSRuntime JSRuntime
@inject IDialogService DialogService

<div class="designer-root">
    <div class="palette-container">
        <MudButton Size="Size.Small"
                   Class="palette-toggle"
                   OnClick="@TogglePalette">Plugins</MudButton>

        <!-- Palette -->
        <div class="palette @(IsPaletteVisible ? "visible" : "hidden")">
            <HeaderTitle Title="Plugins" />
            <SearchablePluginsList OnItemClick="AddNodeTemplate" />
        </div>
    </div>

    <!-- Canvas -->
    <div class="canvas-wrap">
        <div class="canvas-toolbar">
            <MudIconButton Variant="Variant.Text"
                           Size="Size.Medium"
                           Icon="@Icons.Material.Filled.ZoomIn"
                           OnClick="ZoomIn" />

            <MudIconButton Variant="Variant.Text"
                           Size="Size.Medium"
                           Icon="@Icons.Material.Filled.ZoomOut"
                           OnClick="ZoomOut" />

            <MudIconButton Variant="Variant.Text"
                           Size="Size.Medium"
                           Icon="@Icons.Material.Filled.Refresh"
                           OnClick="ZoomReset" />

            <MudIconButton Variant="Variant.Text"
                           Size="Size.Medium"
                           Icon="@Icons.Material.Filled.FilterCenterFocus"
                           OnClick="Center" />
        </div>
        <div id="drawflow" style="height:100%;"></div>
    </div>
</div>

@code {
    [Parameter] public Workflow Workflow { get; set; }

    private WorkflowTask SelectedTask;
    private string _deps;
    private string _newKey;
    private string _newValue;
    private DotNetObjectReference<WorkflowDesigner> _selfRef;
    private bool IsPaletteVisible = true;

    private void TogglePalette()
    {
        IsPaletteVisible = !IsPaletteVisible;
    }

    private Task ZoomIn() => JSRuntime.InvokeVoidAsync("fsDrawflow.zoomIn").AsTask();
    private Task ZoomOut() => JSRuntime.InvokeVoidAsync("fsDrawflow.zoomOut").AsTask();
    private Task ZoomReset() => JSRuntime.InvokeVoidAsync("fsDrawflow.zoomReset").AsTask();
    private Task Center() => JSRuntime.InvokeVoidAsync("fsDrawflow.center").AsTask();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _selfRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("fsDrawflow.init", "drawflow", _selfRef);
            await LoadWorkflowIntoCanvas();
        }
    }

    private async Task LoadWorkflowIntoCanvas()
    {
        await JSRuntime.InvokeVoidAsync("fsDrawflow.clear");
        foreach (var t in Workflow.Tasks)
        {
            var data = new { name = t.Name, type = t.Type, parameters = t.Parameters };
            var id = await JSRuntime.InvokeAsync<int>("fsDrawflow.addNode", t.Name, data, (int)(t.X == 0 ? 100 : t.X), (int)(t.Y == 0 ? 100 : t.Y));
            t.NodeId = id.ToString();
        }
        foreach (var t in Workflow.Tasks)
        {
            foreach (var dep in t.Dependencies)
            {
                var from = Workflow.Tasks.FirstOrDefault(x => x.Name == dep);
                if (from != null)
                    await JSRuntime.InvokeVoidAsync("fsDrawflow.connect", from.NodeId, t.NodeId);
            }
        }
    }

    private async Task AddNodeTemplate(string type)
    {
        var newTask = new WorkflowTask
            {
                Name = $"{type}-{Workflow.Tasks.Count + 1}",
                Type = type,
                X = 120 + (Workflow.Tasks.Count % 5) * 140,
                Y = 120 + (Workflow.Tasks.Count / 5) * 120
            };
        Workflow.Tasks.Add(newTask);
        var data = new { name = newTask.Name, type = newTask.Type, parameters = newTask.Parameters };
        var id = await JSRuntime.InvokeAsync<int>("fsDrawflow.addNode", newTask.Name, data, (int)newTask.X, (int)newTask.Y);
        newTask.NodeId = id.ToString();
        StateHasChanged();
    }

    private void SetParam(string key, string value) => SelectedTask.Parameters[key] = value;
    private void RemoveParam(string key) => SelectedTask.Parameters.Remove(key);
    private void AddParam()
    {
        if (!string.IsNullOrWhiteSpace(_newKey))
        {
            SelectedTask.Parameters[_newKey] = _newValue;
            _newKey = _newValue = null;
        }
    }

    private Task UpdateNodeTitle() =>
        SelectedTask != null ? JSRuntime.InvokeVoidAsync("fsDrawflow.updateNodeTitle", SelectedTask.NodeId, SelectedTask.Name, SelectedTask.Type).AsTask() : Task.CompletedTask;

    private async void ShowPropertiesDialog(WorkflowTask task)
    {
        var options = new DialogOptions
            {
                CloseButton = false,
                MaxWidth = MaxWidth.Small,
                BackdropClick = false,
                CloseOnEscapeKey = false,
                BackgroundClass = "blur-dialog-background"
            };

        var parameters = new DialogParameters
            {
                ["SelectedTask"] = task,
                ["OnUpdated"] = EventCallback.Factory.Create(this, async () =>
                {
                    await UpdateNodeTitle();
                    StateHasChanged();
                })
            };

        await DialogService.ShowAsync<WorkflowNodeProperties>("Properties", parameters, options);
    }

    private void UpdateDepsFromText() =>
        SelectedTask.Dependencies = _deps?.Split(',').Select(s => s.Trim()).Where(s => !string.IsNullOrWhiteSpace(s)).ToList() ?? new();

    [JSInvokable]
    public Task OnNodeSelected(string id)
    {
        SelectedTask = Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        _deps = SelectedTask != null ? string.Join(',', SelectedTask.Dependencies) : string.Empty;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeUnselected() { SelectedTask = null; StateHasChanged(); return Task.CompletedTask; }

    [JSInvokable]
    public Task OnConnectionCreated(string fromId, string toId)
    {
        var from = Workflow.Tasks.FirstOrDefault(x => x.NodeId == fromId);
        var to = Workflow.Tasks.FirstOrDefault(x => x.NodeId == toId);
        if (from != null && to != null && !to.Dependencies.Contains(from.Name))
            to.Dependencies.Add(from.Name);
        _deps = SelectedTask == to ? string.Join(',', to.Dependencies) : _deps;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnConnectionRemoved(string fromId, string toId)
    {
        var from = Workflow.Tasks.FirstOrDefault(x => x.NodeId == fromId);
        var to = Workflow.Tasks.FirstOrDefault(x => x.NodeId == toId);
        to?.Dependencies.Remove(from?.Name);
        _deps = SelectedTask == to ? string.Join(',', to.Dependencies) : _deps;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeRemoved(string id)
    {
        var t = Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        if (t != null)
        {
            Workflow.Tasks.Remove(t);
            foreach (var o in Workflow.Tasks) o.Dependencies.Remove(t.Name);
            if (SelectedTask == t) { SelectedTask = null; _deps = string.Empty; }
        }
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeDoubleClicked(string id)
    {
        var task = Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        if (task != null)
        {
            SelectedTask = task;
            ShowPropertiesDialog(task);
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeProperties(string id)
    {
        var task = Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        if (task != null)
        {
            SelectedTask = task;
            ShowPropertiesDialog(task);
        }
        return Task.CompletedTask;
    }

    public ValueTask DisposeAsync()
    {
        _selfRef?.Dispose();
        return ValueTask.CompletedTask;
    }
}