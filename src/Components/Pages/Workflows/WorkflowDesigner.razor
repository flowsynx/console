@using Microsoft.AspNetCore.Components
@implements IAsyncDisposable

@inject IJSRuntime JSRuntime
@inject IDialogService DialogService

<div class="designer-root">
    <div class="palette-container">
        <MudTooltip Text="@(IsPaletteVisible ? "Close panel" : "Open panel and add plugins")">
            <MudIconButton Variant="Variant.Filled"
                           Size="Size.Medium"
                           Icon="@(IsPaletteVisible ? Icons.Material.Filled.Close : Icons.Material.Filled.Add)"
                           Color="Color.Primary"
                           Class="palette-toggle"
                           OnClick="TogglePalette" />
        </MudTooltip>

        <!-- Palette -->
        <div class="palette @(IsPaletteVisible ? "visible" : "hidden")">
            <HeaderTitle Title="Plugins" Class="px-2 py-2" />
            <SearchablePluginsList OnItemClick="AddNodeTemplate" />
        </div>
    </div>

    <!-- Canvas -->
    <div class="canvas-wrap">
        <div class="canvas-toolbar">
            <MudIconButton Variant="Variant.Text"
                           Size="Size.Medium"
                           Icon="@Icons.Material.Filled.ZoomIn"
                           OnClick="ZoomIn" />

            <MudIconButton Variant="Variant.Text"
                           Size="Size.Medium"
                           Icon="@Icons.Material.Filled.ZoomOut"
                           OnClick="ZoomOut" />

            <MudIconButton Variant="Variant.Text"
                           Size="Size.Medium"
                           Icon="@Icons.Material.Filled.Refresh"
                           OnClick="ZoomReset" />

            <MudIconButton Variant="Variant.Text"
                           Size="Size.Medium"
                           Icon="@Icons.Material.Filled.FilterCenterFocus"
                           OnClick="Center" />
        </div>
        <div id="drawflow" style="height:100%;"></div>
    </div>
</div>

@code {
    [Parameter] public Workflow Workflow { get; set; }

    private WorkflowTask SelectedTask;
    private string _deps;
    private string _newKey;
    private string _newValue;
    private DotNetObjectReference<WorkflowDesigner> _selfRef;
    private bool IsPaletteVisible = false;

    private void TogglePalette()
    {
        IsPaletteVisible = !IsPaletteVisible;
    }

    private Task ZoomIn() => JSRuntime.InvokeVoidAsync("fsDrawflow.zoomIn").AsTask();
    private Task ZoomOut() => JSRuntime.InvokeVoidAsync("fsDrawflow.zoomOut").AsTask();
    private Task ZoomReset() => JSRuntime.InvokeVoidAsync("fsDrawflow.zoomReset").AsTask();
    private Task Center() => JSRuntime.InvokeVoidAsync("fsDrawflow.center").AsTask();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _selfRef = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("fsDrawflow.init", "drawflow", _selfRef);
            await LoadWorkflowIntoCanvas();
        }
    }

    private async Task LoadWorkflowIntoCanvas()
    {
        await JSRuntime.InvokeVoidAsync("fsDrawflow.clear");
        foreach (var t in Workflow.Tasks)
        {
            var data = new { name = t.Name, type = t.Type ?? "LocalFileSystem", parameters = t.Parameters };
            var id = await JSRuntime.InvokeAsync<int>("fsDrawflow.addNode", t.Name, data, (double)(t.Position.X == 0 ? 100 : t.Position.X), (double)(t.Position.Y == 0 ? 100 : t.Position.Y));
            t.NodeId = id.ToString();
        }
        foreach (var t in Workflow.Tasks)
        {
            foreach (var dep in t.Dependencies)
            {
                var from = Workflow.Tasks.FirstOrDefault(x => x.Name == dep);
                if (from != null)
                    await JSRuntime.InvokeVoidAsync("fsDrawflow.connect", from.NodeId, t.NodeId);
            }
        }
    }

    private async Task AddNodeTemplate((string type, string version) plugin)
    {
        var typeValue = plugin.type == "LocalFileSystem"
            ? (object)"LocalFileSystem"
            : new
            {
                Plugin = plugin.type,
                Version = plugin.version,
                Specifications = new Dictionary<string, string>()
            };

        var newTask = new WorkflowTask
            {
                Name = $"{plugin.type}-{Workflow.Tasks.Count + 1}",
                Type = typeValue,
                Position = new(
                    120 + (Workflow.Tasks.Count % 5) * 140,
                    120 + (Workflow.Tasks.Count / 5) * 120
                )
            };

        Workflow.Tasks.Add(newTask);

        string displayType = plugin.type == "LocalFileSystem"
            ? "LocalFileSystem"
            : $"{plugin.type} ({plugin.version})";

        var data = new
        {
            name = newTask.Name,
            type = displayType,   // now always a string
            parameters = newTask.Parameters
        };

        var id = await JSRuntime.InvokeAsync<int>(
            "fsDrawflow.addNode",
            newTask.Name,
            data,
            (double)newTask.Position.X,
            (double)newTask.Position.Y
        );

        newTask.NodeId = id.ToString();
        StateHasChanged();
    }

    private void SetParam(string key, string value) => SelectedTask.Parameters[key] = value;
    private void RemoveParam(string key) => SelectedTask.Parameters.Remove(key);
    private void AddParam()
    {
        if (!string.IsNullOrWhiteSpace(_newKey))
        {
            SelectedTask.Parameters[_newKey] = _newValue;
            _newKey = _newValue = null;
        }
    }

    private Task UpdateNodeTitle() =>
        SelectedTask != null ? JSRuntime.InvokeVoidAsync("fsDrawflow.updateNodeTitle", SelectedTask.NodeId, SelectedTask.Name, SelectedTask.Type ?? "LocalFileSystem").AsTask() : Task.CompletedTask;

    private async void ShowPropertiesDialog(WorkflowTask task)
    {
        var options = new DialogOptions
            {
                CloseButton = false,
                MaxWidth = MaxWidth.Small,
                BackdropClick = false,
                CloseOnEscapeKey = false,
                BackgroundClass = "blur-dialog-background"
            };

        var parameters = new DialogParameters
            {
                ["SelectedTask"] = task,
                ["OnUpdated"] = EventCallback.Factory.Create(this, async () =>
                {
                    await UpdateNodeTitle();
                    StateHasChanged();
                })
            };

        await DialogService.ShowAsync<WorkflowNodeProperties>("Properties", parameters, options);
    }

    private void UpdateDepsFromText() =>
        SelectedTask.Dependencies = _deps?.Split(',').Select(s => s.Trim()).Where(s => !string.IsNullOrWhiteSpace(s)).ToList() ?? new();

    [JSInvokable]
    public Task OnNodeSelected(string id)
    {
        SelectedTask = Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        _deps = SelectedTask != null ? string.Join(',', SelectedTask.Dependencies) : string.Empty;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeUnselected() { SelectedTask = null; StateHasChanged(); return Task.CompletedTask; }

    [JSInvokable]
    public Task OnConnectionCreated(string fromId, string toId)
    {
        var from = Workflow.Tasks.FirstOrDefault(x => x.NodeId == fromId);
        var to = Workflow.Tasks.FirstOrDefault(x => x.NodeId == toId);
        if (from != null && to != null && !to.Dependencies.Contains(from.Name))
            to.Dependencies.Add(from.Name);
        _deps = SelectedTask == to ? string.Join(',', to.Dependencies) : _deps;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnConnectionRemoved(string fromId, string toId)
    {
        var from = Workflow.Tasks.FirstOrDefault(x => x.NodeId == fromId);
        var to = Workflow.Tasks.FirstOrDefault(x => x.NodeId == toId);
        to?.Dependencies.Remove(from?.Name);
        _deps = SelectedTask == to ? string.Join(',', to.Dependencies) : _deps;
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeRemoved(string id)
    {
        var t = Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        if (t != null)
        {
            Workflow.Tasks.Remove(t);
            foreach (var o in Workflow.Tasks) o.Dependencies.Remove(t.Name);
            if (SelectedTask == t) { SelectedTask = null; _deps = string.Empty; }
        }
        StateHasChanged();
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeDoubleClicked(string id)
    {
        var task = Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        if (task != null)
        {
            SelectedTask = task;
            ShowPropertiesDialog(task);
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeProperties(string id)
    {
        var task = Workflow.Tasks.FirstOrDefault(x => x.NodeId == id);
        if (task != null)
        {
            SelectedTask = task;
            ShowPropertiesDialog(task);
        }
        return Task.CompletedTask;
    }

    [JSInvokable]
    public Task OnNodeMoved(string id, double? x, double? y)
    {
        var task = Workflow.Tasks.FirstOrDefault(t => t.NodeId == id);
        if (task != null && x.HasValue && y.HasValue)
        {
            task.Position = new((int)x.Value, (int)y.Value);
            StateHasChanged();
        }
        return Task.CompletedTask;
    }

    public ValueTask DisposeAsync()
    {
        _selfRef?.Dispose();
        return ValueTask.CompletedTask;
    }
}